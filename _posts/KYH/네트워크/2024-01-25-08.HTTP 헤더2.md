---
title : 08.HTTP 헤더2 - 캐시와 조건부 요청
date : 2024-01-25 +09:00
categories : [KYH, network]
tags : [
  네트워크,
]
---
<!-- ![](/assets/img/Spring/aaaa.png){:style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;" } -->
<!-- ![](/assets/img/Performance Test/1-1.png){:style="width:1000px" } -->

### 캐시 기본 동작
- 캐시가 없을 경우 같은 내용을 요청하면 같은 용량에 대해 요청한 만큼 받는다
- 캐시가 있다면, 캐시의 유효 시간이 초과하지 않고 같은 요청을 한다면
- 웹브라우저는 브라우저의 캐시 저장소를 탐색하여 요청에 대한 내용을 출력한다.
- 만약 캐시의 유효시간이 끝났다면, 서버에 요청하여 다시 응답받고 캐시 저장소에 저장하여 유효시간을 갱신한다.

### 검증 헤더와 조건부 요청1
- 캐시 유효 시간이 초과해서 서버에서 다시 요청하면 두 가지 상황이 발생
1. 서버에서 기존 데이터를 변경함
2. 서버에서 기존 데이터를 변경하지 않음

<hr>

- 만약 캐시의 유효시간이 끝났지만 서버에 요청한 데이터가 기존 캐시저장소에 있던 데이터와 동일하다면? 또 불필요하게 서버에서 데이터를 다운받아야 할까???
- 이러한 경우에는 데이터를 전송하는 대신에 저장해 두었던 캐시를 재사용할 수 있다
- 단, 클라이언트 데이터와 서버의 데이터가 같다는 사실을 확인할 수 있는 방법이 필요하다
- 이 방법이 검증 헤더이다

<hr>

- 검증 헤더 추가
1. 첫번째 요청에서 헤더에 Last-Modified 데이터를 추가한다
2. 마지막 수정 시간 내용이 들어간다.
3. 캐시 저장소에서 캐시를 저장할 때, 데이터 최종 수정일을 기록한다
4. 캐시 유효시간이 끝나고 클라이언트가 서버에 요청할 때 요청 메시지에 데이터 최종 수정일(if-modified-since)을 같이 보낸다
5. 서버에서는 요청에 딸려온 데이터 최종 수정일을 비교하고 
6. 304 Not Modified로 보낸다. 이때 Last-Modified를 같이 실어보낸다
7. 그리고 중요한 것을 이때에는 HTTP Body의 내용은 전송하지 않는다
8. 클라이언트는 서버가 보낸 응답 헤더 정보로 캐시의 메타 정보를 갱신한다
9. 클라이언트는 캐시에 저장되어 있는 데이터를 재활용한다
10. 결과적으로 네트워크에서 다운로드가 발생하지만 용량이 적은 헤더 정보만 다운로드하게 된다
11. 서버 다운의 부하가 줄어들고 응답시간이 빠른 효과를 가져올 수 있다

### 검증 헤더와 조건부 요청2
- 검증 헤더
  - 캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
  - Last-Modified, ETag

- 조건부 요청 헤더
  - 검증 헤더로 조건에 따른 분기
  - if-Modified-Since : Last-Modified 사용
  - if-None-Match : ETag 사용
  - 조건이 만족하면 200 OK
  - 조건이 만족하지 않으면 304 Not Modified

1. if-Modified-Since & Last-Modified
- 데이터 미변경 예시
  - 캐시: 2024년 01월 25일 10:00:00 vs 서버: 2024년 01월 25일 10:00:00
  - 실패(변경되었나요?라고 질문 했는데 안바꼈으니, false)
  - 304 Not Modified, 헤더 데이터만 전송(Body 미포함)
  - 전송 용량 0.1M (헤더 0.1M, 바디 1.0M)
- 데이터 변경 예시
  - 캐시: 2024년 01월 25일 10:00:00 vs 서버: 2024년 01월 26일 10:00:00
  - 성공
  - 200 OK, 모든 데이터 전송(Body 포함)
  - 전송 용량 1.1M (헤더 0.1M, 바디 1.0M)

2. if-Modified-Since & Last-Modified의 단점
- 1초 미만 단위로 캐시 조정이 불가능
- 날짜 기반의 로직 사용
- 데이터를 수정해서 날짜가 다르지만, 같은 데이터를 수정해서 데이터 결과가 똑같은 경우
  - 데이터를 수정했지만 결국 다시 원래상태로 돌린경우 수정날짜는 갱신되었지만 컨텐츠 자체는 같음
- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우
  - 주석같은 경우는 컨텐츠에 영향을 주는게 아니기 때문에 캐시를 유지하고 싶은 경우

3. ETag & if-None-Match
- ETag(Entity Tag)
- 캐시용 데이터에 임의의 고유한 버전 이름을 달아둔다
- 데이터가 변경되면 이 이름을 바꾸어서 변경한다(Hash를 다시 생성)
- 진짜 단순하게 ETag만 보내서 같으면 유지하고 다르면 다시 받는다
- 작동원리는 if-Modified-Since & Last-Modified와 같다

4. ETag & if-None-Match 정리
- 단순하게 ETag만 서버에 보내서 같으면 유지, 다르면 받기
- 캐시 제어 로직을 서버에서 완전히 관리한다
- 클라이언트는 단순히 이 값을 서버에 전송한다.(캐시 매커니즘을 모른다)
  - 예) 애플리케이션 배포 주기에 맞춰서 ETag를 모두 갱신

### 캐시와 조건부 요청 헤더
- 캐시 제어 헤더
  - Cache-Control : 캐시제어
  - Pragma : 캐시 제어(하위 호환)
  - Expires : 캐시 유효 기간(하위 호환)

1. Cache-Control : 캐시제어
- Cache-Control : max-age
  - 캐시 유효 시간, 초 단위
- Cache-Control : no-cache
  - 데이터는 캐시해도 되지만, 항상 origin 서버에 검증하고 사용한다.
  - 중간 캐시 서버가 무수히 많다.
- Cache-Control : no-store
  - 데이터에 민감한 정보가 있으므로 저장하면 안된다.
  - 메모리에서 사용하고 최대한 빨리 삭제

2. Pragma : 캐시 제어(하위 호환)
- Pragma : no-cache
- HTTP 1.0 하위 호환

3. Expires : 캐시 유효 기간(하위 호환)
- 캐시 만료일을 정확한 날짜로 지정
- HTTP 1.0부터 사용
- 지금은 더 유연한 Cache-Control : max-age를 권장한다
- Cache-Control : max-age와 함께 사용되면 Expires는 무시된다

### 프록시 캐시
- 원 서버 직접 접근(origin 서버)
- 만약 한국에 있는 클라이언트가 미국에 있는 서버에 직접 접속 한다고 하면 1초의 시간이 걸린다.
- 여러 클라이언트가 미국 서버에 접속하면 각자 1초의 시간이 걸리는 것이다.
- 근데 한국에 미국 서버와 통신하는 프록시 캐시 서버를 만든다고 하면
- 한국 클라이언트는 프록시 캐시 서버를 통해 원하는 자료 요청을 하기 때문에 데이터 다운 시간이 0.1초로 줄어들 수 있을 것이다.
- 물론 처음으로 데이터 요청을 한 클라이언트는 프록시 서버에 캐시 데이터가 없기 때문에 시간이 걸리지만
- 그 이후 클라이언트들은 프록시 캐시 서버에 캐시가 저장되어 있기 때문에 응답을 빠르게 받을 수 있게 된다
- 여기서 클라이언트들에게 있는 캐시를 private 캐시라고 하고
- 프록시 캐시 서버에 있는 캐시를 public 캐시라고 한다

<hr>

- Cache-Control : public
  - 응답이 public 캐시에 저장되어도 됨
- Cache-Control : private
  - 응답이 해당 사용자만을 위한 것임, private 캐시에 저장해야 함(기본값)
- Cache-Control : s-maxage
  - 프록시 캐시에만 적용되는 max-age
- Age: 60(HTTP 헤더)
  - origin 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)

### 캐시 무효화
- 확실한 캐시 무효화 응답
- 캐시를 적용을 안해도 웹브라우저들이 GET 요청인 경우에는 임의로 캐시를 해버리기도 한다
- 그래서 여기서는 무조건 캐시를 하면 안되라고 하려면 밑의 것들을 다 넣어 주어야 한다
  - Cache-Control : no-cache, no-store, must-revalidate
  - Pragma: no-cache
- Cache-Control : must-revalidate
  - 캐시 만료 후 최초 조회시 원 서버에 검증해야 한다
  - 원 서버 접근 실패 시 반드시 오류가 발생해야 한다 - 504(Gateway Timeout)
  - must-revalidate는 캐시 유효 시간이라면 캐시를 사용함
  
  <hr>
- no-cache와 must-revalidate 의 차이
- no-cache의 경우 
1. 캐시 사용을 위해 원서버로 검증을 요청한다.
2. 프록시 서버에서는 캐시 요청을 받고 원 서버로 캐시 요청을 보낸다
3. 원서버에서 프록시 서버로 응답해준다.
4. 프록시 서버에서 클라이언트로 응답해준다
5. 만약 프록시 서버와 원서버 사이에 네트워크 단절이 발생하면
6. 몇몇 프록시 서버에는 사용자의 편의를 위해 에러보다는 옛날 캐시라도 보여주는 것이 낫다고 판단해 세팅이 되어 있는 경우가 있다
7. 이렇게 되면 옛날 캐시로 다시 데이터 다운이 일어나게 된다

- must-revalidate의 경우
1. 만약 프록시 서버와 원서버 사이에 네트워크 단절이 발생하면
2. 프록시 서버는 클라이언트에게 504에러로 응답하게 된다

##### 출처
- 인프런의 김영한님의 강의를 듣고 정리한 것입니다.
