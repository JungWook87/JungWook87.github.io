---
published : true
title : 240304 기록, jwt적용(3)
date : 2024-03-04 +09:00
categories : [MSAProject, MSAProject]
tags : [
  MSAProject,
]
---
<!-- ![](/assets/img/Spring/aaaa.png){:style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;" } -->
<!-- ![](/assets/img/Security/1.png){:style="width:1000px"} -->

### LoginFilter

```java
import com.example.userservice.dto.MyUserDetails;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;

@RequiredArgsConstructor
public class LoginFilter extends UsernamePasswordAuthenticationFilter {
// UsernamePasswordAuthenticationFilter는 원래 HttpSecurity#formLogin에서 진행을 했는데
// jwt를 위해 formLogin을 disable 시켰기 때문에 개발자가 구현해줘야 한다

  private final AuthenticationManager authenticationManager;

  // JWTUtil 클래스를 통해서 로그인이 성공했을 때 토큰 발급
  // SecurityConfig에 가서 LoginFilter 생성자에 JWTUtil 파라미터도 추가해주어야 한다
  private final JWTUtil jwtUtil;

  @Override
  // 미승인 Authentication 생성하는 메소드
  public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException{

      // 요청을 가로채서 username과 password를 추출
      String username = obtainUsername(request);
      String password = obtainPassword(request);

      System.out.println("username : " + username);

      // 스프링 시큐리티에서 username과 password를 검증하기 위해서는 token에 담아야 한다
      UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(username, password, null);
                                                                                          // username, password, role
      // token에 담은 검증을 AuthenticationManager로 전달
      return authenticationManager.authenticate(authToken);
  }

  @Override
  protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authentication) throws IOException, ServletException {
      MyUserDetails myUserDetails = (MyUserDetails) authentication.getPrincipal();
      String username = myUserDetails.getUsername();

      Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
      Iterator<? extends GrantedAuthority> iterator = authorities.iterator();
      GrantedAuthority auth = iterator.next();

      String role = auth.getAuthority();

      String token = jwtUtil.createJwt(username, role, 60*60*10L);

      response.addHeader("Authorization", "Bearer " + token);
      // 위의 HTTP인증방식은 RFC 7235 정의에 의해서 공식적으로 형식을 지정해줌
      // Authorization: 타입 인증토큰
      // Authorization: Bearer 인증토큰string
      // "Bearer "의 경우 공백을 끝에 붙여줘야 함
  }

  @Override
  protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException {
      response.setStatus(401);
  }
}
```

```java
LoginFilter loginFilter = new LoginFilter(authenticationManager(authenticationConfiguration), jwtUtil);
        loginFilter.setFilterProcessesUrl("/api/users/loginProc");
        http
                .addFilterAt(loginFilter, UsernamePasswordAuthenticationFilter.class);
```

- 로그인 성공 시 토큰을 생성하기 위해 로직이 구현되어 있는 JWTUtil을 의존성 주입해 준다
- 시큐리티에서 로그인필터 등록 시 객체를 생성하며 등록을 했는데, JWTUtil을 필드에 선언하였으므로, 그곳에 매개변수로 JWTUtil을 추가해준다.
- 로그인 성공 시 Authentication을 통해 username, role 을 가져와 토큰을 생성한다.
- 생성된 토큰을 response header에 넣어준다. 넣을 때 형식에 주의한다.
- response.addHeader("Authorization", "Bearer " + token);
- Bearer의 뒤에는 공백이 있다.
- 로그인 실패 시 response의 상태를 401 에러로 세팅한다.

##### 테스트
- 포스트맨을 이용하여 로그인 진행
- 로그인 성공 시 응답 헤더 탭으로 가보면 
- Authorization이 있고
- Bearer eyJhbGciOiJIUzI1NiJ9.eyJ1c2VybmFtZSI6InVzZXIyQGFiYy5jb20iLCJyb2xlIjoiUk9MRV9VU0VSIiwiaWF0IjoxNzA5NTM1Nzg4LCJpc3MiOiJqd0tpbSIsImV4cCI6MTcwOTUzNTgyNH0.bhcxG4A0YCplb6-42p4oCUNvEc6LXFPRZ26LSRlr8t0
- 라는 토큰이 발행됨
- 이제 다른 서비스 요청 시 이 토큰의 정보를 담아 요청하면 됨
- 아직은 토큰 검증 로직이 없어서 진행이 되지 않음

##### 트러블슈팅
- 포스트맨으로 로그인을 진행하였는데 에러발생
- ECDSA signing keys must be PrivateKey instances
- 원인을 찾아보니 토큰 생성 시 암호화 알고리즘을 .signWith(key, SignatureAlgorithm.ES256) 로 했었다.
- .signWith(key, SignatureAlgorithm.HS256)로 수정.

### JWT 검증 필터 구현
- JWTUtil에서 .parseClaimsJwt(token) 로 인해서 에러 발생
- Signed Claims JWSs are not supported.
- .parseClaimsJws(token) 로 변경하여 해결

##### 깃 주소
<a href="https://github.com/JungWook87/MSAProject" target="_blank">GitHub</a>
