---
title : 03.HTTP의 기본
date : 2024-01-15 +09:00
categories : [네트워크, network]
tags : [
  네트워크,
]
---
<!-- ![](/assets/img/Spring/aaaa.png){:style="border:1px solid #eaeaea; border-radius: 7px; padding: 0px;" } -->
<!-- ![](/assets/img/Performance Test/1-1.png){:style="width:1000px" } -->

### HTTP

- HTML, TEXT
- IMG, 음성, File, 영상
- JSON, XML(API)
- 거의 모든 형태의 데이터를 전송한다
- 서버간에 데이터를 주고 받을 때소 HTTP를 사용한다.

1. 기반 프로토콜
- HTTP/1.1은 기능 개발이며, 2와 3은 성능 개선에 초점이 있다.
- TCP : HTTP/1.1 , HTTP/2 버전 기반
- UDP : HTTP/3 버전 기반
- 현재는 HTTP/1.1를 주로 사용, HTTP/2, HTTP/3도 점점 늘고 있다.

- 인터넷 접속하여 검사창을 열고 network 탭으로 이동.
- Name, Status... 같은 header에 우클릭하여 protocol을 보게 되면 현재 1.1과 2, 3을 많이 같이 쓰고 있다.

2. HTTP 특징
- 클라이언트 서버 구조
- 무상태 프로토콜(스테이스리스), 비연결성
- HTTP 메시지
- 단순함, 확장 가능

### 클라이언트 서버 구조

- Request Response 구조
- 클라이언트는 요청하고 응답을 기다림
- 서버가 요청에 대한 결과를 응답함

### 무상태 프로토콜

- 서버가 클라이언트의 상태를 보존하지 않는다
- 장점 : 서버 확장성 높음
- 단점 : 클라이언트가 추가 데이터를 전송한다

1. stateful(상태유지)
- 서버가 클라이언트의 상태를 보존한다
- 클라이언트의 요청을 서버가 계속하여 물고 있다.
- 그래서 다음 요청에 대하여도 이전 요청을 참고하여 결과를 줄 수 있다
- 예시
  - 고객이 마트에서 A물건 가격 요청
  - 점원이 A물건의 가격 응답
  - 2개 구매 요청
  - 가격*2에 대한 결과 응답 및 결재 방식 질문
  - 현금으로 하겠다는 요청
  - 현금으로 결재 완료 응답
- but
  - 고객이 A물건 가격 요청
  - 점원A는 가격 응답
  - 고객이 2개 구매 요청
  - 점원B는 무슨 물건인지 모름
  - 고객이 신용카드로 결재 하겠다고 함
  - 점원C는 무슨 물건을 몇개 산다는 건지 모름

- 즉, 상태유지는 클라이언트의 요청을 계속하여 물고 있기 때문에 다음 요청에 대하여 어떤 상태인지를 알 수가 있다.

2. stateless
- 클라이언트의 상태를 보존하지 않는다
- 요청에서 필요한 데이터를 계속하여 넘겨준다.
- 예시
  - 클 : 물건 A 얼마에요?
  - 점원 : 가격 응답
  - 클 : 물건A 2개 구매할게요
  - 점원 : 총 가격 응답
  - 클 : 물건A 2개 신용카드 구매할게요
  - 점 : 결재 완료 응답

- 이 대화에서는 점원이 바뀌어도 필요 요청을 다 제공하기 때문에 새로운 점원이어도 요청에 대하여 응답할 수 있다.

3. stateful 과 stateless의 차이
- 상태유지의 상태 : 점원이 바뀌면 바로 요청에 대하여 응답을 할 수 없기 때문에 에러가 발생하게 된다.
- 무상태 : 중간에 점원이 바뀌어도 상관없다
  - 갑자기 클라이언트의 증가해도 점원을 대거 투입할 수 있다
  - 서버의 입장에서는 클라이언트가 증가하여도, 상태를 관리하지 않기 때문에 서버 증설 후 어느 서버에든지 연결하여 처리하면 된다.
- 상태 유지에서는 통신하던 서버가 죽으면 클라이언트는 처음부터 요청을 다시 진행하여야 한다
- 무상태에서는 통신하던 서버가 죽어도 다른 서버에서 응답하면 된다

- 실무에서는 로그인 같은 경우 상태를 유지하여야 서비스가 이용가능하므로 브라우저 쿠키와 서버 세션 등을 사용하여 최소한의 유지 기능을 사용하도록 한다.
- 무상태의 단점으로는 요청시 데이터를 많이 보내야 한다.

### 비연결성

- 연결성 : 서버가 연결을 유지하면, 클라이언트에서 요청이 없어도 계속하여 서버의 자원을 쓰게된다.
- 비연결성 : 클라이언트와 요청을 주고 받을 때만 서버를 연결한다. 서버가 최소한의 자원을 사용한다

- HTTP는 기본이 비연결성을 띈다

1. 한계와 극복
- TCP/IP의 연결을 새로 맺어야 하기 때문에 3 wqy handshake를 하는 시간이 추가된다.
- HTML 뿐만 아니라 JS, CSS, 이미지 등등 많은 자료들이 많은 자원이 함께 다운로드 된다.
- 예전에는
  - 연결 > HTML 요청 > 응답 > 종료
  - 연결 > JS 요청 > 응답 > 종료
  - 연결 > CSS 요청 > 응답 > 종료 
- 따라서 지금은 HTTP는 지속 연결로 문제를 해결했다.
  - 연결 > HTML 요청 > JS 요청 > CSS 요청 > 종료

### HTTP 메시지

1. HTTP 메시지 구조
- start-line 시작 라인
- header 헤더
- empty line 공백라인(CRLF)
- message body

2. 시작 라인   
- 1) 요청 메시지
- request-line / status-line
- request-line = method SP(공백) request-target SP HTTP-version CRLF(엔터)  
- HTTP 메서드    
  - 종류 : GET, POST, PUT, DELETE 등    
- 요청 대상    
  - 보통 절대경로로 시작, 쿼리가 합쳐져 들어가기도 한다    
- 2) 응답 메시지
- request-line / status-line
- status-line = HTTP-version SP status-code SP reason-phrase CRLF
- HTTP 상태코드    
  - 요청 성공, 실패를 나타낸다
  - 200 : 성공
  - 400 : 클라이언트 요청 오류
  - 500 : 서버 내부 오류   
- 이유 문구   
  - 사람이 이해할 수 있는 짧은 상태 코드 설명글.
  - 200 OK

3. HTTP 헤더
- field-name: OWS field-value OWS (OWS는 띄어쓰기 허용이란 뜻)
- 단, field-name과 ":" 사이는 띄어쓰기 허용 X
- field-name은 대소문자 구분 X, value는 대소문자 구분 O
- 용도
  - HTTP 전송에 필요한 모든 부가정보
  - 표준 헤더가 너무 많다
  - 필요시 임의의 헤더 추가 가능

4. HTTP 메시지 바디
- 실제 전송할 데이터
- HTML 문서, 이미지, JSON 등등
